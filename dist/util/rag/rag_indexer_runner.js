#!/usr/bin/env node
import{execFile as et}from"node:child_process";import{createHash as nt}from"node:crypto";import p from"node:fs/promises";import{promisify as st}from"node:util";import f from"node:path";import*as v from"@lancedb/lancedb";import{join as x}from"node:path";var l=x(process.cwd(),".voice","code-index"),$="code_index_chunks",_="qwen/qwen3-embedding-8b",A=300*1e3,R=x(process.cwd(),".voice","code-index","status.json");import D from"node:fs/promises";import k from"node:path";import{openrouter as W}from"@openrouter/ai-sdk-provider";import{embed as $t,embedMany as X}from"ai";var E=k.join(l,".logs"),Z=k.join(E,"indexer.log"),F=8,K=W.textEmbeddingModel(_);async function Y(e){try{await D.mkdir(E,{recursive:!0}),await D.appendFile(Z,`${e}
`,"utf8")}catch{}}function Q(e){if(e instanceof Error){let n=e,s=JSON.stringify(e,Object.getOwnPropertyNames(e)),t=typeof n.responseBody=="string"?`
responseBody:
${n.responseBody}`:"",i=n.requestBodyValues!==void 0?`
requestBodyValues:
${JSON.stringify(n.requestBodyValues)}`:"",a=n.statusCode?`
statusCode: ${n.statusCode}`:"",m=n.url?`
url: ${n.url}`:"";return`${e.name}: ${e.message}${a}${m}${i}${t}
${s}
${e.stack??""}`}try{return JSON.stringify(e)}catch{return String(e)}}function tt(e){let n=[];for(let s=0;s<e.length;s+=F)n.push(e.slice(s,s+F));return n}async function O(e){if(e.length===0)return[];let n=tt(e),s=[];for(let t of n)try{let{embeddings:i}=await X({model:K,values:t});s.push(...i)}catch(i){throw await Y(`[${new Date().toISOString()}] embedMany error ${Q(i)}`),i}return s}var M=st(et),L=200,it=2e5,rt=["-lock."],B=50;function T(e,n){let s=e.split(f.sep);if(s.some(i=>i.startsWith(".")))return!0;let t=s[s.length-1]??e;return!!(t.startsWith(".")||rt.some(i=>t.includes(i))||n.some(i=>e.startsWith(`${i}${f.sep}`)))}var P=f.join(l,".logs"),at=f.join(P,"indexer.log");async function o(e){try{await p.mkdir(P,{recursive:!0}),await p.appendFile(at,`${e}
`,"utf8")}catch(n){console.error("RAG indexer: failed to write log",n)}}async function u(e){try{await p.writeFile(R,JSON.stringify(e,null,2),"utf8")}catch(n){console.error("RAG indexer: failed to write status",n)}}function ot(e){return nt("sha256").update(e).digest("hex")}function j(e){return e.split("'").join("''")}function ct(e){let n=e.split(`
`),s=[];for(let t=0;t<n.length;t+=B){let i=n.slice(t,t+B);i.length!==0&&s.push({text:i.join(`
`),startLine:t+1,endLine:t+i.length})}return s}async function dt(e){try{let{stdout:n}=await M("git",["ls-files","-co","--exclude-standard","-z"],{cwd:e,maxBuffer:52428800});return n.split("\0").filter(Boolean)}catch(n){return console.error("RAG indexer: git ls-files failed, skipping index",n),[]}}async function lt(e){try{let{stdout:n}=await M("find",[".","-name",".git","-print"],{cwd:e,maxBuffer:20971520});return n.split(`
`).map(s=>s.trim()).filter(Boolean).map(s=>s.replace(/^\.\//,"")).filter(s=>s!==".git").map(s=>s.replace(/\/\.git$/,""))}catch(n){return console.error("RAG indexer: find .git failed",n),[]}}async function G(e,n){if(n.length!==0)for(let s=0;s<n.length;s+=L){let i=n.slice(s,s+L).map(a=>`'${j(a)}'`).join(", ");await e.delete(`path IN (${i})`)}}async function N(e){try{return await e.openTable($)}catch{return null}}async function ut(){await p.mkdir(l,{recursive:!0})}async function pt(){let e=process.cwd();await ut();let n=await dt(e),s=await lt(e),t={state:"indexing",totalFiles:n.length,processedFiles:0,updatedFiles:0,skippedFiles:0,lastRunAt:new Date().toISOString()};if(await u(t),await o(`[${t.lastRunAt}] start total=${t.totalFiles}`),n.length===0){t.state="idle",await u(t),await o(`[${new Date().toISOString()}] idle no files`);return}let i=await v.connect(l),a=await N(i),m=a?await a.query().select(["path","hash"]).toArray():[],H=new Map(m.map(r=>[r.path,r.hash])),U=n.filter(r=>T(r,s)),V=new Set(n);if(a){let r=m.map(d=>d.path).filter(d=>!V.has(d));await G(a,r),await G(a,U)}let y=!1;for(let r of n){if(t.processedFiles+=1,T(r,s)){t.skippedFiles+=1,await o(`[${new Date().toISOString()}] skipped ${r} reason=ignored`);continue}let d=f.join(e,r),S;try{S=await p.stat(d)}catch{t.skippedFiles+=1,await o(`[${new Date().toISOString()}] skipped ${r} reason=stat-failed`);continue}if(S.size>it){t.skippedFiles+=1,await o(`[${new Date().toISOString()}] skipped ${r} reason=size bytes=${S.size}`);continue}let g;try{g=await p.readFile(d,"utf8")}catch{t.skippedFiles+=1,await o(`[${new Date().toISOString()}] skipped ${r} reason=read-failed`);continue}if(g.length===0){t.skippedFiles+=1,await o(`[${new Date().toISOString()}] skipped ${r} reason=empty`);continue}if(g.includes("\0")){t.skippedFiles+=1,await o(`[${new Date().toISOString()}] skipped ${r} reason=binary`);continue}let I=ot(g);if(H.get(r)===I){t.skippedFiles+=1,await o(`[${new Date().toISOString()}] skipped ${r} reason=unchanged`);continue}let w=ct(g);a&&await a.delete(`path = '${j(r)}'`),await o(`[${new Date().toISOString()}] embedding ${r} chunks=${w.length}`);let z=await O(w.map(c=>c.text)),J=new Date().toISOString(),b=w.map((c,h)=>({path:r,chunk_index:h,start_line:c.startLine,end_line:c.endLine,hash:I,vector:z[h]??[],updatedAt:J,bytes:Buffer.byteLength(c.text,"utf8")}));if(!a)try{a=await i.createTable($,b),await o(`[${new Date().toISOString()}] created table rows=${b.length}`)}catch(c){let h=c instanceof Error?c.message:String(c);if(await o(`[${new Date().toISOString()}] create table failed ${h}`),a=await N(i),!a)throw c}await a.mergeInsert(["path","chunk_index"]).whenMatchedUpdateAll().whenNotMatchedInsertAll().execute(b),y=!0,t.updatedFiles+=1,await o(`[${new Date().toISOString()}] indexed ${r} chunks=${w.length}`),t.processedFiles%20===0&&(t.lastRunAt=new Date().toISOString(),await u(t))}if(!y){t.state="idle",t.lastRunAt=new Date().toISOString(),await u(t),await o(`[${t.lastRunAt}] idle processed=${t.processedFiles} updated=${t.updatedFiles} skipped=${t.skippedFiles}`);return}t.state="idle",t.lastRunAt=new Date().toISOString(),await u(t),await o(`[${t.lastRunAt}] done processed=${t.processedFiles} updated=${t.updatedFiles} skipped=${t.skippedFiles}`)}function C({intervalMs:e=A}={}){let n=!1,s=async()=>{if(!n){n=!0;try{await pt()}catch(i){let a=i instanceof Error?i.message:String(i);await u({state:"error",totalFiles:0,processedFiles:0,updatedFiles:0,skippedFiles:0,lastRunAt:new Date().toISOString(),message:a}),await o(`[${new Date().toISOString()}] error ${a}`)}finally{n=!1}}};s();let t=setInterval(s,e);return()=>{clearInterval(t)}}var gt=C(),q=()=>{gt(),process.exit(0)};process.on("SIGINT",q);process.on("SIGTERM",q);
